///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2020 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Using Configuration for CORS
:javadoc-base-url-api: {javadoc-base-url}io.helidon.webserver.cors/io/helidon/webserver/cors
:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver
:h1Prefix: SE
:pagename: cors-configuration
:description: Helidon CORS Configuration
:keywords: helidon, java, cors, configuration
:cors-se-intro: 01_introduction.adoc
:cors-se-api-doc: 02_using-the-api.adoc
:cors-config-table-src: {cors-se-api-doc}
:mapped-config-top-key: my-cors
:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}
:helidon-se-cors-example: {helidon-tag}/examples/cors

Use configuration in combination with the Helidon CORS SE API to add CORS support to your resources.
Loading the CORS information for different types of resource sharing from declarative configuration,
instead of hard-coding it in your procedural Java code,
not only simplifies the code but also gives your users a way to override the CORS behavior of your
services without requiring the code to change.


== Understanding the CORS Configuration Formats [[cors-configuration-formats]]
Support in Helidon for CORS configuration uses two closely-related cross-origin configuration formats: basic and mapped.
Each format corresponds to a class
in the Helidon CORS library.
The basic format corresponds to the link:{javadoc-base-url-api}/CrossOriginConfig.html[`CrossOriginConfig`]
class, and the mapped format corresponds to the
link:{javadoc-base-url-api}/MappedCrossOriginConfig.html[`MappedCrossOriginConfig`] class.

[[basic-cross-origin-config]]
=== Basic Cross-Origin Configuration
In configuration, Helidon represents basic CORS information as a section, identified by a configuration
key of your choosing, that contains
one or more key/value pairs. Each key-value pair assigns one characteristic of CORS behavior.

The table below lists the configuration keys that identify the CORS characteristics.

[[config-key-table]]
:cors-config-table-exclude-methods:
include::{cors-config-table-src}[tag=cors-config-table]

The following example of basic cross-origin configuration, when loaded and used by the application, limits cross-origin resource sharing for `PUT` and
`DELETE` operations to only `foo.com` and `there.com`:

[source,hocon]
----
...
restrictive-cors:
  allow-origins: ["http://foo.com", "http://there.com"]
  allow-methods: ["PUT", "DELETE"]
...
----


=== Mapped Cross-Origin Configuration
In some cases, you or your users might want to configure CORS behavior based on URL path matching.
// tag::mapped-config[]
Helidon represents mapped CORS information as a section, identified by a configuration
key of your choosing, that contains:

* An optional `enabled` setting which defaults to `true` and applies to the whole mapped CORS config section, and

* An optional `paths` subsection containing zero or more entries, each of which contains:

** a basic CORS config section, and

** a `path-pattern` path pattern that maps that basic CORS config section to the resource(s) it affects.

You can use mapped configuration to your advantage if you want to allow your users to override the CORS behavior set up
in the application code.

The following example illustrates the mapped cross-origin configuration format.

[source,hocon,subs="attributes+"]
----
...
{mapped-config-top-key}: <1>
  paths: <2>
    - path-pattern: /greeting <3>
      allow-origins: ["http://foo.com", "http://there.com", "http://other.com"] <4>
      allow-methods: ["PUT", "DELETE"]
    - path-pattern: / <5>
      allow-methods: ["GET", "HEAD", "OPTIONS", "POST"] <6>
...
----
<1> Assigns a unique identifier for this mapped CORS config section.
<2> Collects the sequence of entries, each of which maps a basic CORS config to a path pattern.
<3> Marks the beginning of an entry (the `-` character) and maps the associated basic CORS config
to the `/greeting` subresource (the `path-pattern` key and value).
<4> Begins the basic CORS config section for `/greeting`; it
restricts sharing via `PUT` and `DELETE` to the listed origins.
<5> Marks the beginning of the next entry (the `-` character) and maps the associated basic CORS config to
the top-level resource in the app (the `path-pattern` key and value).
<6> Begins the basic CORS config section for `/`; it permits sharing of resources at the top-level path with all origins
for the indicated HTTP methods.

Path patterns can be any expression accepted by the link:{javadoc-base-url-webserver}/PathMatcher.html[`PathMatcher`] class.

NOTE: Be sure to arrange the entries in the order that you want Helidon to check them, typically from most specific to most general.
Helidon CORS support searches the cross-origin entries in the order you define them until it finds an entry that
matches an incoming request's path pattern and HTTP method.
// end::mapped-config[]


[[using-config-from-app]]
== Using CORS Configuration in the Application
You use configuration in combination with the Helidon CORS SE API
to add CORS support to your resources. The example in <<se/cors/02_using-the-api.adoc#se-api-routing-example,Sample Routing Setup Using the `CrossOriginConfig` API>>
uses the low-level Helidon CORS SE API to create
a `CorsSupport` instance that is then used to create the routing rules. As an alternative to using the low-level API, this example uses config to create the
`CorsSupport` instance instead.


[source,java]
----
    private static Routing createRouting(Config config) {

        MetricsSupport metrics = MetricsSupport.create();
        GreetService greetService = new GreetService(config);
        HealthSupport health = HealthSupport.builder()
                .addLiveness(HealthChecks.healthChecks())   // Adds a convenient set of checks
                .build();
        CorsSupport.Builder builder = CorsSupport.builder();

        Config config = Config.create(); // Created from the current config sources
        config.get("my-cors") // <1>
                .ifExists(builder::mappedConfig);
        config.get("restrictive-cors") // <2>
                .ifExists(builder::config);
        builder.addCrossOriginConfig(CrossOriginConfig.create()); // <3>

        CorsSupport corsSupport = builder.build(); // <4>

        // Note: Add the CORS routing *before* registering the GreetService routing.
        return Routing.builder()
                .register(JsonSupport.create())
                .register(health)                   // Health at "/health"
                .register(metrics)                 // Metrics at "/metrics"
                .register("/greet", corsSupport, greetService) // <5>
                .build();
    }
----
<1> If `my-cors` exists in the configuration, use it to add mapped CORS config to the `CorsSupport` builder.
<2> If `restrictive-cors` exists in the configuration, use it to add basic (not mapped) config to the builder.
<3> Provide default CORS handling for requests that do not match earlier entries.
<4> Obtain the finished `CorsSupport` instance.
<5> Use `corsSupport` in constructing the routing rules.


As each request arrives, Helidon checks it against the cross-origin config instances in the order that your application
added them to the `CorsSupport.Builder`.
The `my-cors` mapped configuration acts as an override because the application added it to the builder first.
If the `my-cors` config key does not appear in the configuration, then the code skips creating a `CrossOriginConfig`
instance based on that configuration, and no overriding occurs. The CORS behavior
that is established by the other `CrossOriginConfig` instance based on the `restrictive-cors` config (if present)
prevails.

NOTE: Remember that if you set configuration in a file that you include as part of your application JAR file, then you need to
rebuild and restart your application for any changes to take effect.

== Next Steps

* Use these same configuration techniques to control the behavior of the CORS-enabled built-in services.
<<se/cors/04_support-in-builtin-services.adoc, Learn more.>>
* See the Helidon CORS support in action by building and running the link:{helidon-se-cors-example}[CORS example].
