///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2020 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Using Configuration for CORS
:javadoc-base-url-api: {javadoc-base-url}io.helidon.webserver.cors/io/helidon/webserver/cors
:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver
:pagename: cors-configuration
:description: Helidon CORS Configuration
:keywords: helidon, java, cors, configuration
:cors-se-intro: 01_introduction.adoc
:cors-se-api-doc: 02_using-the-api.adoc
:cors-config-table-src: {cors-se-api-doc}
:mapped-config-top-key: my-cors
:cors-config-table-exclude-methods:
:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}
:helidon-se-cors-example: {helidon-tag}/examples/cors

Your application can use configuration in setting up CORS behavior.

== Understanding Configuration and CORS
The <<se/cors/02_using-the-api.adoc,Using the Helidon SE CORS API>> section describes the changes
you make to your application to incorporate CORS.
Although your Helidon SE application must include some minimal coding changes,
you can reduce the amount of change needed in your app by using configuration.
Loading the CORS information for different types of resource sharing from declarative configuration,
instead of hard-coding it in your procedural Java code,
not only simplifies the code but also gives your users a way to customize the CORS behavior of your
services without requiring the code to change.

This section introduces the two CORS
<<cors-configuration-formats, configuration formats>> and describes
<<using-config-from-app, how to use>> the Helidon CORS API together with config.

== Mastering the CORS Configuration Formats [[cors-configuration-formats]]
The support in Helidon for CORS configuration works with two closely-related formats. Each corresponds to a class
in the Helidon CORS library.

[[basic-cross-origin-config]]
=== Basic Cross-Origin Configuration
Cross-origin configuration is the basic building block of CORS information.

[[config-key-table]]
include::{cors-config-table-src}[tag=cors-config-table]

The following example configuration, when loaded and used by the application, limits cross-origin resource sharing for `PUT` and
`DELETE` operations to only `foo.com` and `there.com`:

[source,hocon]
----
...
restrictive-cors:
  allow-origins: ["http://foo.com", "http://there.com"]
  allow-methods: ["PUT", "DELETE"]
...
----
// tag::mapped-config[]

=== Mapped Cross-Origin Configuration
In some cases, you or your users might want to configure CORS behavior based on URL path matching. The following example of the  _mapped_
configuration format illustrates this.

[source,hocon,subs="attributes+"]
----
...
{mapped-config-top-key}:
  paths:
    - path-prefix: /greeting <1>
      allow-origins: ["http://foo.com", "http://there.com", "http://other.com"]
      allow-methods: ["PUT", "DELETE"]
    - path-prefix: / <2>
      allow-methods: ["GET", "HEAD", "OPTIONS", "POST"]
...
----
<1> Sets restrictions on CORS for the `/greeting` path.
<2> Permits sharing of resources at the top-level path with all origins (the default) for the indicated HTTP methods.
Cross-origin sharing via `PATCH` HTTP requests would be denied.

Path expressions can be any expression accepted by the link:{javadoc-base-url-webserver}/PathMatcher.html[`PathMatcher`] class.

Arrange the entries in the order that you want Helidon to check them. Usually this is from most specific to most general.
Helidon CORS support searches the cross-origin entries in the order you define them until it finds an entry that
matches an incoming request's path expression and HTTP method.
// end::mapped-config[]

You might want to avoid using mapped configuration to set up the _normal_ CORS behavior in your application, because you have to
make sure the paths are the same in the configuration and in the code that establishes routing for your application.
You _can_ use mapped configuration to your advantage if you want to allow your users to override the CORS behavior set up
in the application code. See the example below.

[[using-config-from-app]]
== Using CORS Configuration in the Application
To use basic or mapped CORS configuration, you add logic to your application to load sections of configuration and
use the loaded config to build `CrossOriginConfig` instances. (The
<<se/cors/01_introduction.adoc#intro-quick-start-code-example, `CrossOriginConfig` Routing Example>> shows
this in practice.)

You can create
a `CrossOriginConfig` instance directly from a config node, as shown in this example.

[source,java]
----
CorsSupport.Builder builder = CorsSupport.builder();

Config config = Config.create(); // Created from the current config sources

config.get("my-cors") // <1>
    .ifExists(builder::mappedConfig);

config.get("restrictive-cors") // <2>
    .ifExists(builder::config);

builder.addCrossOriginConfig(CrossOriginConfig.create()); // <3>

CorsSupport corsSupport = builder.build(); // <4>
----
<1> If `my-cors` exists in the configuration, use it to add mapped CORS config to the `CorsSupport` builder.
<2> If `restrictive-cors` exists in the configuration, use it to add basic (not mapped) config to the builder.
<3> Provide default CORS handling for requests that do not match earlier entries.
<4> Obtain the finished `CorsSupport` instance, suitable for use in creating the application's routing.

As each request arrives, Helidon checks it against the cross-origin config instances in the order that your application
added them to the `CorsSupport.Builder`.
The `my-cors` mapped configuration acts as an override because the application added it to the builder first.
If the `my-cors` config key does not appear in the configuration, then the code skips creating a `CrossOriginConfig`
instance based on that configuration, and no overriding occurs. The CORS behavior
that is established by the other `CrossOriginConfig` instance based on the `restrictive-cors` config (if present)
prevails.

== Next Steps
* See the Helidon CORS support in action by building and running the link:{helidon-se-cors-example}[CORS example].
* Learn how to use these same techniques to control the behavior of the CORS-enabled built-in services,
described in the <<se/cors/04_support-in-builtin-services.adoc, CORS in Built-in Services>> documentation.
